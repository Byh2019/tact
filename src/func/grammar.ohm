FunC {
  Module = Pragma* Include* ModuleItem*

  //
  // Compiler pragmas and includes
  //

  Pragma = "#pragma" ("allow-post-modification" | "compute-asm-ltr") ";" --literal
         | "#pragma" ("version" | "not-version") versionRange ";" --versionRange
         | "#pragma" "test-version-set" stringLiteral ";" --versionString

  Include = "#include" stringLiteral ";"

  //
  // Top-level, module items
  //

  ModuleItem = GlobalVariablesDeclaration
             | ConstantsDefinition
             | AsmFunctionDefinition
             | FunctionDeclaration
             | FunctionDefinition

  //
  // Declarations of global variables
  //

  GlobalVariablesDeclaration = "global" NonemptyListOf<GlobalVariableDeclaration, ","> ";"
  GlobalVariableDeclaration = TypeGlob? id

  TypeGlob = TypeBuiltinGlob ("->" TypeGlob)?

  TypeBuiltinGlob = "int" | "cell" | "slice" | "builder" | "cont" | "tuple"
                  | "_" | unit | tupleEmpty | TensorGlob | TupleGlob

  TensorGlob = "(" ListOf<TypeGlob, ","> ")"
  TupleGlob = "[" ListOf<TypeGlob, ","> "]"

  //
  // Definitions of constants
  //

  ConstantsDefinition = "const" NonemptyListOf<ConstantDefinition, ","> ";"
  ConstantDefinition = ("slice" | "int")? id "=" Expression

  //
  // Definitions of asm functions
  //

  AsmFunctionDefinition = FunctionCommonPrefix "asm" AsmArrangement? stringLiteral+ ";"

  AsmArrangement = "(" "->" &#whiteSpace integerLiteralDec+ ")" --returns
                 | "(" id+ ~"->" ")" --arguments
                 | "(" id+ &#whiteSpace "->" &#whiteSpace integerLiteralDec+ ")" --argumentsToReturns

  //
  // Function declarations, definitions and common prefix of their syntax
  //

  FunctionDeclaration = FunctionCommonPrefix ";"
  FunctionDefinition = FunctionCommonPrefix "{" Statement* "}"
  FunctionCommonPrefix = Forall? TypeReturn functionId Parameters FunctionAttribute*

  // forall type1, ..., typeN ->
  Forall = "forall" &#whiteSpace NonemptyListOf<TypeVar, ","> &#whiteSpace "->" &#whiteSpace
  TypeVar = ("type" &#whiteSpace)? id

  // Function return types
  TypeReturn = TypeBuiltinReturn (&#whiteSpace "->" &#whiteSpace TypeReturn)?

  TypeBuiltinReturn = "int" | "cell" | "slice" | "builder" | "cont" | "tuple"
                    | "_" | unit | tupleEmpty | TensorReturn | TupleReturn | id

  TensorReturn = "(" ListOf<TypeReturn, ","> ")"
  TupleReturn = "[" ListOf<TypeReturn, ","> "]"

  // Function parameters
  Parameters = "(" ListOf<Parameter, ","> ")"
  Parameter = TypeParameter &#whiteSpace (hole | id) --regular
            | (hole | id) --inferredType

  // Function parameter types
  TypeParameter = TypeBuiltinParameter (&#whiteSpace "->" &#whiteSpace TypeParameter)?

  TypeBuiltinParameter = "int" | "cell" | "slice" | "builder" | "cont" | "tuple"
                       | unit | tupleEmpty | TensorParameter | TupleParameter | id

  TensorParameter = "(" ListOf<TypeParameter, ","> ")"
  TupleParameter = "[" ListOf<TypeParameter, ","> "]"

  // Called "specifiers" in https://docs.ton.org/develop/func/functions#specifiers
  FunctionAttribute = "impure" | "inline_ref" | "inline" | MethodIdValue | "method_id"
  MethodIdValue = "method_id" "(" integerLiteral ")" --int
                | "method_id" "(" stringLiteral ")" --string

  //
  // Statements (with mandatory whitespace padding in most places )
  //

  Statement = StatementReturn
            | StatementBlock
            | StatementEmpty
            | StatementCondition
            | StatementRepeat
            | StatementUntil
            | StatementWhile
            | StatementTryCatch
            | StatementExpression

  StatementReturn = "return" &#whiteSpace Expression ";"

  StatementBlock = "{" &#whiteSpace Statement* &#whiteSpace "}"

  StatementEmpty =  ";"

  StatementCondition = ("ifnot" | "if") &#whiteSpace
                       Expression &#whiteSpace "{" &#whiteSpace Statement* &#whiteSpace "}" &#whiteSpace
                       ("elseifnot" | "elseif") &#whiteSpace
                       Expression &#whiteSpace "{" &#whiteSpace Statement* &#whiteSpace "}" --withElseCondition

                     | ("ifnot" | "if") &#whiteSpace
                       Expression &#whiteSpace "{" &#whiteSpace Statement* &#whiteSpace "}" &#whiteSpace
                       "else" &#whiteSpace
                       "{" &#whiteSpace Statement* &#whiteSpace "}" --withElse

                     | ("ifnot" | "if") &#whiteSpace
                       Expression &#whiteSpace "{" &#whiteSpace Statement* &#whiteSpace "}" --noElse

  StatementRepeat = "repeat" &#whiteSpace Expression  &#whiteSpace "{" &#whiteSpace Statement* &#whiteSpace "}"

  StatementUntil = "do" &#whiteSpace "{" &#whiteSpace Statement* &#whiteSpace "}" &#whiteSpace "until" &#whiteSpace Expression ";"

  StatementWhile = "while" &#whiteSpace Expression &#whiteSpace "{" &#whiteSpace Statement* &#whiteSpace "}"

  StatementTryCatch = "try" &#whiteSpace
                      "{" &#whiteSpace Statement* &#whiteSpace "}" &#whiteSpace
                      "catch" &#whiteSpace "(" (unusedId | id) "," (unusedId | id) ")" &#whiteSpace
                      "{" &#whiteSpace Statement* &#whiteSpace "}"

  StatementExpression = Expression &#whiteSpace ";"

  //
  // Expressions, ordered by precedence (from lowest to highest),
  // with comments referencing exact function names in C++ code of FunC's parser:
  // https://github.com/ton-blockchain/ton/blob/master/crypto/func/parse-func.cpp
  //

  // parse_expr
  Expression = ExpressionAssign

  // parse_expr10
  ExpressionAssign = ExpressionConditional
                     &#whiteSpace ("=" | "+=" | "-=" | "*=" | "/=" | "%="
                          | "~/=" | "~%=" | "^/=" | "^%=" | "&="
                          | "|=" | "^=" | "<<=" | ">>=" | "~>>=" | "^>>=") &#whiteSpace
                     ExpressionAssign --op
                   | ExpressionConditional

  // parse_expr13
  ExpressionConditional = ExpressionCompare
                          &#whiteSpace "?" &#whiteSpace Expression
                          &#whiteSpace ":" &#whiteSpace ExpressionConditional --ternary
                        | ExpressionCompare

  // parse_expr15
  ExpressionCompare = ExpressionBitwiseShift
                      &#whiteSpace ("==" | "<=>" | "<=" | "<" | ">=" | ">" | "!=") &#whiteSpace
                      ExpressionBitwiseShift --op
                    | ExpressionBitwiseShift

  // parse_expr17
  ExpressionBitwiseShift = ExpressionAddBitwise
                           (&#whiteSpace ("<<" | ">>" | "~>>" | "^>>") &#whiteSpace
                            ExpressionAddBitwise)+ --ops
                         | ExpressionAddBitwise

  // parse_expr20
  ExpressionAddBitwise = ("-" &#whiteSpace)?
                         ExpressionMulBitwise
                         (&#whiteSpace ("+" | "-" | "|" | "^") &#whiteSpace
                          ExpressionMulBitwise)+ --ops
                       | ExpressionMulBitwise

  // parse_expr30
  ExpressionMulBitwise = ExpressionUnary
                         (&#whiteSpace ("*" | "/%" | "/" | "%"
                            | "~/" | "~%" | "^/" | "^%" | "&") &#whiteSpace
                          ExpressionUnary)+ --ops
                       | ExpressionUnary

  // parse_expr75
  ExpressionUnary = "~" &#whiteSpace ExpressionMethod --bitwiseNot
                  | ExpressionMethod

  // parse_expr80
  ExpressionMethod = ExpressionVarFun (methodId &("(" | "[" | id) ExpressionPrimary)+ --calls
                   | ExpressionVarFun

  // parse_expr90
  ExpressionVarFun =
    | ExpressionPrimary (&("(" | "[" | Id) ExpressionPrimary)+ --functionCall
    | Type (&("(" | "[" | Id) ExpressionPrimary) --polymorphVarDecl
    // hole in TypeUniform
    | TypeUniform (&("(" | "[" | Id) ExpressionPrimary) --uniformVarDecl
    | ExpressionPrimary



  // parse_expr100
  ExpressionPrimary =
                    | unit
                    | ExpressionTensor
                    | tupleEmpty
                    | ExpressionTuple
                    | hole
                    | typePrimitive
                    | integerLiteral
                    | booleanExpression
                    | nilExpression
                    | stringLiteral
                    | id


  restrictedId = ~((hole | integerLiteral | delimiter | operator) ~id) id
  restrictedFunctionId =  ~((hole | integerLiteral | delimiter | operator) ~functionId) functionId
  ExpressionTensor = "(" ListOf<Expression, ","> ")"
  ExpressionTuple = "[" ListOf<Expression, ","> "]"


  //
  // Miscellaneous syntactic rules, see: https://ohmjs.org/docs/syntax-reference#syntactic-lexical
  //

  // Argument = id

  // Mapped or unmapped builtin types or type variables,
  // where "mapped" refers to: https://docs.ton.org/develop/func/types#functional-type
  // and type variables refer to parametric polymorphism with `forall`
  Type = TypeBuiltin "->" Type --mapped
       | TypeBuiltin --builtin
       // | Id --var
  // builtin -> primitive
  typePrimitive = "int" | "cell" | "slice" | "builder" | "cont" | "tuple"

  // Builtin types
  TypeBuiltin = "int" | "cell" | "slice" | "builder" | "cont" | "tuple"
              | Tensor | Tuple | unit | tupleEmpty | restrictedId
              // | Id


  // Non-functional composite builtin types
  Tensor = "(" ListOf<Type, ","> ")"
  Tuple = "[" ListOf<Type, ","> "]"

  // Non-polymorphic, uniform types
  TypeUniform = TypeBuiltinUniform "->" TypeUniform --mapped
              | TypeBuiltinUniform --builtin

  TypeBuiltinUniform = "int" | "cell" | "slice" | "builder" | "cont" | "tuple"
                     | hole | TensorUniform | TupleUniform | unit | tupleEmpty

  TensorUniform = "(" ListOf<TypeUniform, ","> ")"

  TupleUniform = "[" ListOf<TypeUniform, ","> "]"

  //
  // Lexical rules, see: https://ohmjs.org/docs/syntax-reference#syntactic-lexical
  //

  // Special types or values
  hole = "_" | "var" ~id
  unit = "()"
  tupleEmpty = "[]"

  // Operators and delimiters
  operator = ("+" | "-" | "*" | "/%" | "/" | "%"
                 | "~/" | "^/" | "~%" | "^%") --arithOperator
           | ("<=>" | "<=" | "<" | ">=" | ">" | "!=" | "==") --comparisonOperator
           | ("~>>" | "~" | "^>>" | "^" | "&" | "|" | "<<" | ">>") --bitwiseOperator
           | ("=" | "+=" | "-=" | "*=" | "/=" | "%=" | "~>>="
                  | "~/=" | "~%=" | "^>>=" | "^/=" | "^%=" | "^="
                  | "<<=" | ">>=" | "&=" | "|=") --assignOperator
  delimiter = "{" | "}" | "?" | ":"


  // Function identifiers
  functionId = ~("\"" | "{-") ("." | "~")? rawId
  methodId = ~("\"" | "{-") ("." | "~") rawId

  // Identifiers, with invalidation (keywords, numbers, etc.) during syntax analysis
  // — this makes this parser closer to the C++ one, and also improves error messages

  // TODO: re-work everything here!!!! Literally everything!
  rawId = quotedId | plainId

  id = ~("\"" | "{-" | "." | "~") rawId

  quotedId = "`" (~("`" | "\n") any)+ "`"
  plainId = (~(whiteSpace | "(" | ")" | "[" | "]" | "," | "." | ";" | "~") any)+

  // Unused identifiers
  unusedId = "_"

  /*
    FunC can parse much more than Fift can handle. For example, _0x0 and _0 are valid identifiers in FunC, and using either of them compiles and is then interpreted fine by Fift. But if you use both, FunC still compiles, but Fift crashes.

    Same goes for plain identifiers using hashes # or emojis — you can have one FunC function with any of those combinations of characters, but you (generally) cannot have two or more of such functions.
  */

  // Version ranges
  versionRange = ("=" | "^" | "<=" | ">=" | "<" | ">")? integerLiteralDec ("." integerLiteralDec)? ("." integerLiteralDec)?

  // Integers
  integerLiteral = "-"? integerLiteralNonNegative
  integerLiteralNonNegative = integerLiteralHex | integerLiteralDec

  // hexDigit is defined in Ohm's built-in rules as: hexDigit = "0".."9" | "a".."f" | "A".."F"
  integerLiteralHex = "0x" hexDigit+

  // digit is defined in Ohm's built-in rules as: digit = "0".."9"
  integerLiteralDec = digit+

  // Boolean expressions (builtins.cpp)
  booleanExpression = "true" | "false"

  // Nil expressions (builtins.cpp)
  nilExpression = "nil" | "Nil"

  // Strings
  stringLiteral = "\"\"\"" (~"\"\"\"" any)* "\"\"\"" stringType? --multiLine
                | "\"" (~"\"" any)* "\"" stringType? --singleLine

  stringType = "s" --sliceHex
             | "a" --sliceInternalAddress
             | "u" --intHex
             | "h" --int32Sha256
             | "H" --int256Sha256
             | "c" --intCrc32

  // Whitespace
  space += comment | lineTerminator
  whiteSpace = "\t" | " " | lineTerminator

  // Comments
  comment = ";;" (~lineTerminator any)* --singleLine
          | multiLineComment --multiLine

  // Nested multi-line comments
  multiLineComment = "{-" (~("-}" | "{-") any)* multiLineComment? (~"-}" any)* "-}"

  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
}
