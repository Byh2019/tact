FunC {
  Module = Pragma* Include* ModuleItem*

  //
  // Compiler pragmas and includes
  //

  Pragma = "#pragma" ("allow-post-modification" | "compute-asm-ltr") ";" --literal
         | "#pragma" ("version" | "not-version") versionRange ";" --versionRange
         | "#pragma" "test-version-set" stringLiteral ";" --versionString

  Include = "#include" stringLiteral ";"

  //
  // Top-level, module items
  //

  ModuleItem = GlobalVariablesDeclaration
             | ConstantsDefinition
             | AsmFunctionDefinition
             | FunctionDeclaration
             | FunctionDefinition

  GlobalVariablesDeclaration = "global" NonemptyListOf<GlobalVariableDeclaration, ","> ";"
  GlobalVariableDeclaration = TypeUniform? id

  ConstantsDefinition = "const" NonemptyListOf<ConstantDefinition, ","> ";"
  ConstantDefinition = ("slice" | "int")? id "=" Expression

  AsmFunctionDefinition = FunctionCommonPrefix "asm" AsmArrangement? stringLiteral+ ";"

  AsmArrangement = "(" "->" integerLiteralDec+ ")" --returns
                 | "(" id+ ~"->" ")" --arguments
                 | "(" id+ "->" integerLiteralDec+ ")" --argumentsToReturns

  FunctionDeclaration = FunctionCommonPrefix ";"

  FunctionDefinition = FunctionCommonPrefix "{" Statement* "}"

  // Common prefix of function declarations and definitions
  FunctionCommonPrefix = Forall? Type functionId Parameters FunctionAttribute*

  // forall type1, ..., typeN ->
  Forall = "forall" NonemptyListOf<TypeVar, ","> "->"
  TypeVar = "type"? id

  // Parameters, with holes allowed for identifiers
  Parameters = "(" ListOf<Parameter, ","> ")"
  Parameter = Type id --regular
            | id --inferredType

  // Called "specifiers" in https://docs.ton.org/develop/func/functions#specifiers
  FunctionAttribute = "impure" | "inline_ref" | "inline" | MethodIdValue | "method_id"
  MethodIdValue = "method_id" "(" integerLiteral ")" --int
                | "method_id" "(" stringLiteral ")" --string

  //
  // Statements
  //

  Statement = StatementReturn
            | StatementBlock
            | StatementEmpty
            | StatementCondition
            | StatementRepeat
            | StatementUntil
            | StatementWhile
            | StatementTryCatch
            | StatementExpression

  StatementReturn = "return" Expression ";"
  StatementBlock = "{" Statement* "}"
  StatementEmpty = ";"
  StatementCondition = ("ifnot" | "if" ) Expression "{" Statement* "}" ("elseifnot" | "elseif") Expression "{" Statement* "}" --withElseCondition
                     | ("ifnot" | "if" ) Expression "{" Statement* "}" "else" "{" Statement* "}" --withElse
                     | ("ifnot" | "if" ) Expression "{" Statement* "}" --noElse
  StatementRepeat = "repeat" Expression "{" Statement* "}"
  StatementUntil = "do" "{" Statement* "}" "until" Expression ";"
  StatementWhile = "while" Expression "{" Statement* "}"
  StatementTryCatch = "try" "{" Statement* "}" "catch" "(" (unusedId | id) "," (unusedId | id) ")" "{" Statement* "}"
  StatementExpression = Expression ";"

  //
  // Expressions, ordered by precedence (from lowest to highest),
  // with comments referencing exact function names in C++ code of FunC's parser:
  // https://github.com/ton-blockchain/ton/blob/master/crypto/func/parse-func.cpp
  //

  // parse_expr
  Expression = ExpressionAssign

  // parse_expr10
  ExpressionAssign = ExpressionConditional "="    ExpressionAssign --assign
                   | ExpressionConditional "+="   ExpressionAssign --addAssign
                   | ExpressionConditional "-="   ExpressionAssign --subAssign
                   | ExpressionConditional "*="   ExpressionAssign --mulAssign
                   | ExpressionConditional "/="   ExpressionAssign --divAssign
                   | ExpressionConditional "%="   ExpressionAssign --modAssign
                   | ExpressionConditional "~/="  ExpressionAssign --divRoundAssign
                   | ExpressionConditional "~%="  ExpressionAssign --modRoundAssign
                   | ExpressionConditional "^/="  ExpressionAssign --divCeilAssign
                   | ExpressionConditional "^%="  ExpressionAssign --modCeilAssign
                   | ExpressionConditional "&="   ExpressionAssign --bitwiseAndAssign
                   | ExpressionConditional "|="   ExpressionAssign --bitwiseOrAssign
                   | ExpressionConditional "^="   ExpressionAssign --bitwiseXorAssign
                   | ExpressionConditional "<<="  ExpressionAssign --shlAssign
                   | ExpressionConditional ">>="  ExpressionAssign --shrAssign
                   | ExpressionConditional "~>>=" ExpressionAssign --shrRoundAssign
                   | ExpressionConditional "^>>=" ExpressionAssign --shrCeilAssign
                   | ExpressionConditional

  // parse_expr13
  ExpressionConditional = ExpressionCompare "?" Expression ":" ExpressionConditional --ternary
                        | ExpressionCompare

  // parse_expr15
  ExpressionCompare = ExpressionBitwiseShift "=="  ExpressionBitwiseShift --eq
                    | ExpressionBitwiseShift "<=>" ExpressionBitwiseShift --spaceship
                    | ExpressionBitwiseShift "<="  ExpressionBitwiseShift --lte
                    | ExpressionBitwiseShift "<"   ExpressionBitwiseShift --lt
                    | ExpressionBitwiseShift ">="  ExpressionBitwiseShift --gte
                    | ExpressionBitwiseShift ">"   ExpressionBitwiseShift --gt
                    | ExpressionBitwiseShift "!="  ExpressionBitwiseShift --neq
                    | ExpressionBitwiseShift

  // parse_expr17
  ExpressionBitwiseShift = ExpressionAddBitwise ("<<"  ExpressionAddBitwise)+ --shl
                         | ExpressionAddBitwise (">>"  ExpressionAddBitwise)+ --shr
                         | ExpressionAddBitwise ("~>>" ExpressionAddBitwise)+ --shrRound
                         | ExpressionAddBitwise ("^>>" ExpressionAddBitwise)+ --shrCeil
                         | ExpressionAddBitwise

  // parse_expr20
  ExpressionAddBitwise = ("-" &#whiteSpace)? ExpressionMulBitwise ("+" ExpressionMulBitwise)+ --add
                       | ("-" &#whiteSpace)? ExpressionMulBitwise ("-" ExpressionMulBitwise)+ --sub
                       | ("-" &#whiteSpace)? ExpressionMulBitwise ("|" ExpressionMulBitwise)+ --bitwiseOr
                       | ("-" &#whiteSpace)? ExpressionMulBitwise ("^" ExpressionMulBitwise)+ --bitwiseXor
                       | ("-" &#whiteSpace) ExpressionMulBitwise --minus
                       | ExpressionMulBitwise

  // parse_expr30
  ExpressionMulBitwise = ExpressionUnary ("*"  ExpressionUnary)+ --mul
                       | ExpressionUnary ("/%" ExpressionUnary)+ --divMod
                       | ExpressionUnary ("/"  ExpressionUnary)+ --div
                       | ExpressionUnary ("%"  ExpressionUnary)+ --mod
                       | ExpressionUnary ("~/" ExpressionUnary)+ --divRound
                       | ExpressionUnary ("~%" ExpressionUnary)+ --modRound
                       | ExpressionUnary ("^/" ExpressionUnary)+ --divCeil
                       | ExpressionUnary ("^%" ExpressionUnary)+ --modCeil
                       | ExpressionUnary ("&"  ExpressionUnary)+ --bitwiseAnd
                       | ExpressionUnary

  // parse_expr75
  ExpressionUnary = "~" &#whiteSpace ExpressionMethod --bitwiseNot
                  | ExpressionMethod

  // parse_expr80
  ExpressionMethod = ExpressionVarFun (methodId &("(" | "[" | Id) ExpressionPrimary)+ --call
                   | ExpressionVarFun

  // parse_expr90
  ExpressionVarFun =
    | ExpressionPrimary (&("(" | "[" | Id) ExpressionPrimary)+ --functionCall
    | Type (&("(" | "[" | Id) ExpressionPrimary) --polymorphVarDecl
    // hole in TypeUniform
    | TypeUniform (&("(" | "[" | Id) ExpressionPrimary) --uniformVarDecl
    | ExpressionPrimary



  // parse_expr100
  ExpressionPrimary = stringLiteral
                    | integerLiteral
                    | ExpressionTensor
                    | unit
                    | ExpressionTuple
                    | tupleEmpty
                    | FunctionId // id???
  Id = ~(hole | integerLiteral | delimiter | operator) id
  FunctionId =  ~(hole | integerLiteral | delimiter | operator) functionId

  ExpressionTensor = "(" ListOf<Expression, ","> ")"
  ExpressionTuple = "[" ListOf<Expression, ","> "]"


  //
  // Miscellaneous syntactic rules, see: https://ohmjs.org/docs/syntax-reference#syntactic-lexical
  //

  // Argument = id

  // Mapped or unmapped builtin types or type variables,
  // where "mapped" refers to: https://docs.ton.org/develop/func/types#functional-type
  // and type variables refer to parametric polymorphism with `forall`
  Type = TypeBuiltin "->" Type --mapped
       | TypeBuiltin --builtin
       // | Id --var

  // Builtin types
  TypeBuiltin = "int" | "cell" | "slice" | "builder" | "cont" | "tuple"
              | Tensor | Tuple | unit | tupleEmpty | Id


  // Non-functional composite builtin types
  Tensor = "(" ListOf<Type, ","> ")"
  Tuple = "[" ListOf<Type, ","> "]"

  // Non-polymorphic, uniform types
  TypeUniform = TypeBuiltinUniform "->" TypeUniform --mapped
              | TypeBuiltinUniform --builtin

  TypeBuiltinUniform = "int" | "cell" | "slice" | "builder" | "cont" | "tuple"
                     | hole | TensorUniform | TupleUniform | unit | tupleEmpty

  TensorUniform = "(" ListOf<TypeUniform, ","> ")"

  TupleUniform = "[" ListOf<TypeUniform, ","> "]"

  //
  // Lexical rules, see: https://ohmjs.org/docs/syntax-reference#syntactic-lexical
  //

  // Special types or values
  hole = "_" | "var"
  unit = "()"
  tupleEmpty = "[]"

  // Operators and delimiters
  operator = ("+" | "-" | "*" | "/%" | "/" | "%"
                 | "~/" | "^/" | "~%" | "^%") --arithOperator
           | ("<=>" | "<=" | "<" | ">=" | ">" | "!=" | "==") --comparisonOperator
           | ("~>>" | "~" | "^>>" | "^" | "&" | "|" | "<<" | ">>") --bitwiseOperator
           | ("=" | "+=" | "-=" | "*=" | "/=" | "%=" | "~>>="
                  | "~/=" | "~%=" | "^>>=" | "^/=" | "^%=" | "^="
                  | "<<=" | ">>=" | "&=" | "|=") --assignOperator
  delimiter = "{" | "}" | "?" | ":"


  // Function identifiers
  functionId = ~("\"" | "{-") ("." | "~")? (quotedId | plainId)
  methodId = ~("\"" | "{-") ("." | "~") (quotedId | plainId)

  // Identifiers, with invalidation (keywords, numbers, etc.) during syntax analysis
  // — this makes this parser closer to the C++ one, and also improves error messages

  id = ~("\"" | "{-" | "." | "~") (quotedId | plainId)

  quotedId = "`" (~("`" | "\n") any)+ "`"
  plainId = (~(whiteSpace | "(" | ")" | "[" | "]" | "," | "." | ";" | "~") any)+

  // Unused identifiers
  unusedId = "_"

  /*
    FunC can parse much more than Fift can handle. For example, _0x0 and _0 are valid identifiers in FunC, and using either of them compiles and is then interpreted fine by Fift. But if you use both, FunC still compiles, but Fift crashes.

    Same goes for plain identifiers using hashes # or emojis — you can have one FunC function with any of those combinations of characters, but you (generally) cannot have two or more of such functions.
  */

  // Version ranges
  versionRange = ("=" | "^" | "<=" | ">=" | "<" | ">")? integerLiteralDec ("." integerLiteralDec)? ("." integerLiteralDec)?

  // Integers
  integerLiteral = "-"? integerLiteralNonNegative
  integerLiteralNonNegative = integerLiteralHex | integerLiteralDec

  // hexDigit is defined in Ohm's built-in rules as: hexDigit = "0".."9" | "a".."f" | "A".."F"
  integerLiteralHex = "0x" hexDigit+

  // digit is defined in Ohm's built-in rules as: digit = "0".."9"
  integerLiteralDec = digit+

  // Strings
  stringLiteral = "\"\"\"" (~"\"\"\"" any)* "\"\"\"" stringType? --multiLine
                | "\"" (~"\"" any)* "\"" stringType? --singleLine

  stringType = "s" --sliceHex
             | "a" --sliceInternalAddress
             | "u" --intHex
             | "h" --int32Sha256
             | "H" --int256Sha256
             | "c" --intCrc32

  // Whitespace
  space += comment | lineTerminator
  whiteSpace = "\t" | " " | lineTerminator

  // Comments
  comment = ";;" (~lineTerminator any)* --singleLine
          | multiLineComment --multiLine

  // Nested multi-line comments
  multiLineComment = "{-" (~("-}" | "{-") any)* multiLineComment? (~"-}" any)* "-}"

  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
}
