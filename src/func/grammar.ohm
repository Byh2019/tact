FunC {
  Module = Pragma* Include* ModuleItem*

  //
  // Compiler pragmas and includes
  //

  Pragma = "#pragma" ("allow-post-modification" | "compute-asm-ltr") ";" --literal
         | "#pragma" ("version" | "not-version") versionRange ";" --versionRange
         | "#pragma" "test-version-set" stringLiteral ";" --versionString

  Include = "#include" stringLiteral ";"

  //
  // Top-level, module items
  //

  ModuleItem = GlobalVariablesDeclaration
             | ConstantsDefinition
             | AsmFunctionDefinition
             | FunctionDeclaration
             | FunctionDefinition

  GlobalVariablesDeclaration = "global" NonemptyListOf<GlobalVariableDeclaration, ","> ";"
  GlobalVariableDeclaration = Type? id

  ConstantsDefinition = "const" NonemptyListOf<ConstantDefinition, ","> ";"
  ConstantDefinition = TypeConstant? id "=" Expression

  AsmFunctionDefinition = FunctionCommonPrefix "asm" AsmArrangement? stringLiteral+ ";" --singleLine
                        | FunctionCommonPrefix "asm" AsmArrangement? multiLineString+ ";" --multiLine

  AsmArrangement = "(" "->" integerLiteralDec+ ")" --returns
                 | "(" id+ ~"->" ")" --arguments
                 | "(" id+ "->" integerLiteralDec+ ")" --argumentsToReturns


  FunctionDeclaration = FunctionCommonPrefix ";"

  FunctionDefinition = FunctionCommonPrefix "{" Statement* "}"

  // Common prefix of function declarations and definitions
  FunctionCommonPrefix = Forall? Type functionId Parameters FunctionAttribute*

  // Called "specifiers" in https://docs.ton.org/develop/func/functions#specifiers
  FunctionAttribute = "impure" | "inline_ref" | "inline" | MethodIdValue | "method_id"
  MethodIdValue = "method_id" "(" integerLiteralNonNegative ")"

  //
  // Statements
  //

  Statement = StatementReturn
            | StatementBlock
            | StatementEmpty
            | StatementCondition
            | StatementRepeat
            | StatementUntil
            | StatementWhile
            | StatementTryCatch
            | StatementExpression

  StatementReturn = "return" Expression ";"
  StatementBlock = "{" Statement* "}"
  StatementEmpty = ";"
  StatementCondition = ("if" | "ifnot") Expression "{" Statement* "}" --noElse
                     | ("if" | "ifnot") Expression "{" Statement* "}" "else" "{" Statement* "}" --withElse
                     | ("if" | "ifnot") Expression "{" Statement* "}" ("elseif" | "elseifnot") "{" Statement* "}" --withElseCondition
  StatementRepeat = "repeat" Expression "{" Statement* "}"
  StatementUntil = "do" "{" Statement* "}" "until" Expression ";"
  StatementWhile = "while" Expression "{" Statement* "}"
  StatementTryCatch = "try" "{" Statement* "}" "catch" "(" (unusedId | id) "," (unusedId | id) ")" "{" Statement* "}"
  StatementExpression = Expression ";"

  //
  // Expressions, ordered by precedence (from lowest to highest),
  // with comments referencing exact function names in C++ code of FunC's parser:
  // https://github.com/ton-blockchain/ton/blob/master/crypto/func/parse-func.cpp
  //

  // NOTE: they should parse exactly as FunC 0.4.4 does it, including the issues with precedences of ^ | and similar

  // parse_expr
  // Expression = integerLiteral | stringLiteral | id // FIXME temporary, for tests prior to expressions
  Expression = ExpressionAssign

  // parse_expr10
  ExpressionAssign = ExpressionConditional "="    ExpressionAssign --assign
                   | ExpressionConditional "+="   ExpressionAssign --addAssign
                   | ExpressionConditional "-="   ExpressionAssign --subAssign
                   | ExpressionConditional "*="   ExpressionAssign --mulAssign
                   | ExpressionConditional "/="   ExpressionAssign --divAssign
                   | ExpressionConditional "%="   ExpressionAssign --modAssign
                   | ExpressionConditional "~/="  ExpressionAssign --divRoundAssign
                   | ExpressionConditional "~%="  ExpressionAssign --modRoundAssign
                   | ExpressionConditional "^/="  ExpressionAssign --divCeilAssign
                   | ExpressionConditional "^%="  ExpressionAssign --modCeilAssign
                   | ExpressionConditional "&="   ExpressionAssign --bitwiseAndAssign
                   | ExpressionConditional "|="   ExpressionAssign --bitwiseOrAssign
                   | ExpressionConditional "^="   ExpressionAssign --bitwiseXorAssign
                   | ExpressionConditional "<<="  ExpressionAssign --shlAssign
                   | ExpressionConditional ">>="  ExpressionAssign --shrAssign
                   | ExpressionConditional "~>>=" ExpressionAssign --shrRoundAssign
                   | ExpressionConditional "^>>=" ExpressionAssign --shrCeilAssign
                   | ExpressionConditional

  // parse_expr13
  ExpressionConditional = ExpressionCompare "?" Expression ":" ExpressionConditional --ternary
                        | ExpressionCompare

  // parse_expr15
  ExpressionCompare = ExpressionBitwiseShift "=="  ExpressionBitwiseShift --eq
                    | ExpressionBitwiseShift "<"   ExpressionBitwiseShift --lt
                    | ExpressionBitwiseShift ">"   ExpressionBitwiseShift --gt
                    | ExpressionBitwiseShift "<="  ExpressionBitwiseShift --lte
                    | ExpressionBitwiseShift ">="  ExpressionBitwiseShift --gte
                    | ExpressionBitwiseShift "!="  ExpressionBitwiseShift --neq
                    | ExpressionBitwiseShift "<=>" ExpressionBitwiseShift --spaceship
                    | ExpressionBitwiseShift

  // parse_expr17
  ExpressionBitwiseShift = ExpressionAddBitwise "<<"  ExpressionAddBitwise --shl
                         | ExpressionAddBitwise ">>"  ExpressionAddBitwise --shr
                         | ExpressionAddBitwise "~>>" ExpressionAddBitwise --shrRound
                         | ExpressionAddBitwise "^>>" ExpressionAddBitwise --shrCeil
                         | ExpressionAddBitwise

  // parse_expr20
  ExpressionAddBitwise = "-"? ExpressionMulBitwise "+" ExpressionMulBitwise --add
                       | "-"? ExpressionMulBitwise "-" ExpressionMulBitwise --sub
                       | "-"? ExpressionMulBitwise "|" ExpressionMulBitwise --bitwiseOr
                       | "-"? ExpressionMulBitwise "^" ExpressionMulBitwise --bitwiseXor
                       | "-" ExpressionMulBitwise --minus
                       | ExpressionMulBitwise

  // parse_expr30
  ExpressionMulBitwise = ExpressionUnary "*"  ExpressionUnary --mul
                       | ExpressionUnary "/%" ExpressionUnary --divMod
                       | ExpressionUnary "/"  ExpressionUnary --div
                       | ExpressionUnary "%"  ExpressionUnary --mod
                       | ExpressionUnary "~/" ExpressionUnary --divRound
                       | ExpressionUnary "~%" ExpressionUnary --modRound
                       | ExpressionUnary "^/" ExpressionUnary --divCeil
                       | ExpressionUnary "^%" ExpressionUnary --modCeil
                       | ExpressionUnary "&"  ExpressionUnary --bitwiseAnd
                       | ExpressionUnary

  // parse_expr75
  ExpressionUnary = "~" ExpressionMethodCall --bitwiseNot
                  | ExpressionMethodCall

  // parse_expr80
  ExpressionMethodCall = ExpressionSequence ("." | "~") id ExpressionPrimary --call
                       | ExpressionSequence

  // FIXME: Temporary definition for debugging purposes.
  ExpressionSequence = integerLiteral | multiLineString | stringLiteral | id
  ExpressionPrimary = integerLiteral | multiLineString | stringLiteral | id

  // parse_expr90, FIXME: this is wrong and has to be re-made :)
  // TODO: function call
  // TODO: variable declaration
  // ExpressionSequence = ExpressionPrimary &"(" ExpressionPrimary --call
  //                    | ExpressionPrimary &"[" ExpressionPrimary --access
  //                    | ExpressionPrimary ~("." | "~") id ExpressionPrimary --id
  //                    | ExpressionPrimary

  // parse_expr100, order is important
  // ExpressionPrimary = ExpressionTuple
  //                   | ExpressionTensor
  //                   | integerLiteral
  //                   | stringLiteral
  //                   | hole
  //                   | primitiveType // TODO: re-make this one.
  //                   | id // includes true|false, null|Null
  // TODO: parens!
  // TODO: unit?
  // TODO: slice_string_ident?

  // TODO: ...
  ExpressionTuple = "(" "TODO:" ")"
  ExpressionTensor = "[" "TODO:" "]"

  //
  // Miscellaneous syntactic rules, see: https://ohmjs.org/docs/syntax-reference#syntactic-lexical
  //

  // forall type1, ..., typeN ->
  Forall = "forall" NonemptyListOf<TypeVar, ","> "->"
  TypeVar = "type"? id

  // Parameters, with type holes prohibited during syntax analysis
  Parameters = "(" ListOf<Parameter, ","> ")"
  Parameter = Type id --regular
            | id id --typeVar

  // Arguments -- unused?
  Arguments = "(" ListOf<Argument, ","> ")"
  Argument = id

  // Mapped or unmapped builtin types, where "mapped" refers to:
  // https://docs.ton.org/develop/func/types#functional-type
  Type = TypeBuiltin "->" Type --mapped
       | TypeBuiltin

  // Builtin types
  TypeBuiltin = "int"
                | "cell"
                | "slice"
                | "builder"
                | "cont"
                | "tuple"
                | hole
                | unit
                | Tensor
                | Tuple
                // | id
                // TODO: Use different type signatures in forall functions?

  // Non-functional composite builtin types
  Tensor = "(" NonemptyListOf<Type, ","> ")"
  Tuple = "[" NonemptyListOf<Type, ","> "]"

  // Allowed types of constants
  TypeConstant = "int" | "slice"
  
  //
  // Lexical rules, see: https://ohmjs.org/docs/syntax-reference#syntactic-lexical
  //

  // Special types
  hole = "_" | "var"
  unit = "()"

  // Function identifiers
  functionId = ~("\"" | "{-") ("." | "~")? id

  // Identifiers, with invalidation (keywords, numbers, etc.) during syntax analysis
  // — this makes this parser closer to the C++ one, and also improves error messages

  id = ~("\"" | "{-") (quotedId | plainId)

  quotedId = "`" (~("`" | "\n") any)+ "`"
  plainId = (~(whiteSpace | "(" | ")" | "[ | ]" | "," | "." | ";" | "~") any)+

  // Unused identifiers
  unusedId = "_"

  /*
    FunC can parse much more than Fift can handle. For example, _0x0 and _0 are valid identifiers in FunC, and using either of them compiles and is then interpreted fine by Fift. But if you use both, FunC still compiles, but Fift crashes.

    Same goes for plain identifiers using hashes # or emojis — you can have one FunC function with any of those combinations of characters, but you (generally) cannot have two or more of such functions.
  */

  // Version ranges
  versionRange = ("=" | "^" | "<=" | ">=" | "<" | ">")? integerLiteralDec ("." integerLiteralDec)? ("." integerLiteralDec)?

  // Integers
  integerLiteral = "-"? integerLiteralNonNegative
  integerLiteralNonNegative = integerLiteralHex
                            | integerLiteralDec

  // hexDigit is defined in Ohm's built-in rules as: hexDigit = "0".."9" | "a".."f" | "A".."F"
  integerLiteralHex = "0x" hexDigit+

  // digit is defined in Ohm's built-in rules as: digit = "0".."9"
  integerLiteralDec = digit+

  // Strings
  stringLiteral = "\"" (~"\"" any)* "\"" stringType?
  stringType = "s" --sliceHex
             | "a" --sliceInternalAddress
             | "u" --intHex
             | "h" --int32Sha256
             | "H" --int256Sha256
             | "c" --intCrc32
  multiLineString = "\"\"\"" (~"\"\"\"" any)* "\"\"\""

  // Whitespace
  space += comment | lineTerminator
  whiteSpace = "\t" | " " | lineTerminator

  // Comments
  comment = ";;" (~lineTerminator any)* --singleLine
          | multiLineComment --multiLine

  // Nested multi-line comments
  multiLineComment = "{-" (~("-}" | "{-") any)* multiLineComment? (~"-}" any)* "-}"

  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
}
