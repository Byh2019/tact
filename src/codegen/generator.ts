import { CompilationOutput } from "../pipeline/compile";
import { CompilerContext } from "../context";
import { CodegenContext, ModuleGen } from ".";
import { topologicalSort } from "../utils/utils";
import { ContractABI } from "@ton/core";
import { FuncFormatter } from "../func/formatter";
import { FuncAstModule, FuncAstFunctionDefinition } from "../func/syntax";
import {
    makeComment,
    makeModule,
    makePragma,
    makeInclude,
    declarationFromDefinition,
} from "../func/syntaxUtils";
import { calculateIPFSlink } from "../utils/calculateIPFSlink";

export type GeneratedFilesInfo = {
    files: { name: string; code: string }[];
    imported: string[];
};

/**
 * Func version used to compile the generated code.
 */
export const CODEGEN_FUNC_VERSION = "0.4.4";

/**
 * Generates Func files that correspond to the input Tact project.
 */
export class FuncGenerator {
    private tactCtx: CompilerContext;
    /** An ABI structure of the project generated by the Tact compiler. */
    private abiSrc: ContractABI;
    /** Basename used e.g. to name the generated Func files. */
    private basename: string;
    private funcCtx: CodegenContext;

    private constructor(
        tactCtx: CompilerContext,
        abiSrc: ContractABI,
        basename: string,
    ) {
        this.tactCtx = tactCtx;
        this.abiSrc = abiSrc;
        this.basename = basename;
        this.funcCtx = new CodegenContext(tactCtx);
    }

    static fromTactProject(
        tactCtx: CompilerContext,
        abiSrc: ContractABI,
        basename: string,
    ): FuncGenerator {
        return new FuncGenerator(tactCtx, abiSrc, basename);
    }

    /**
     * Translates the whole Tact project to Func.
     * @returns Information about generated Func files and their code.
     */
    public async writeProgram(): Promise<CompilationOutput> {
        const abi = JSON.stringify(this.abiSrc);
        const abiLink = await calculateIPFSlink(Buffer.from(abi));

        const generated: GeneratedFilesInfo = { files: [], imported: [] };
        const mainContract = this.generateMainContract(
            this.abiSrc.name!,
            abiLink,
        );
        const functions = this.extractFunctions(mainContract);
        this.generateHeaders(generated, functions);
        this.generateStdlib(generated, functions);
        this.generateNative(generated);
        this.generateConstants(generated, functions);
        this.generateStorage(generated, functions);

        // TODO: Everything must be already included to the main contract; otherwise we should add entries from the context
        //
        // const remainingFunctions = tryExtractModule(functions, null, imported);
        // const header: string[] = [];
        // header.push("#pragma version =0.4.4;");
        // header.push("#pragma allow-post-modification;");
        // header.push("#pragma compute-asm-ltr;");
        // header.push("");
        // for (const i of files.map((v) => `#include "${v.name}";`)) {
        //     header.push(i);

        // Finalize and dump the main contract, as we have just obtained the structure of the project
        mainContract.entries.unshift(
            ...generated.files.map((f) => makeInclude(f.name)),
        );
        mainContract.entries.unshift(
            ...[
                `version =${CODEGEN_FUNC_VERSION}`,
                "allow-post-modification",
                "compute-asm-ltr",
            ].map(makePragma),
        );
        generated.files.push({
            name: `${this.basename}.code.fc`,
            code: new FuncFormatter().dump(mainContract),
        });

        // header.push("");
        // header.push(";;");
        // header.push(`;; Contract ${abiSrc.name} functions`);
        // header.push(";;");
        // header.push("");
        // const code = emit({
        //     header: header.join("\n"),
        //     functions: remainingFunctions,
        // });
        // files.push({
        //     name: basename + ".code.fc",
        //     code,
        // });

        return {
            entrypoint: `${this.basename}.code.fc`,
            files: generated.files,
            abi,
        };
    }

    /**
     * Runs the generation of the main contract.
     * This generates some entries from the bottom-up saving them in CodegenContext.
     */
    private generateMainContract(
        mainContractName: string,
        abiLink: string,
    ): FuncAstModule {
        const m = ModuleGen.fromTact(
            this.funcCtx,
            mainContractName,
        ).writeAll();
        return m;
    }

    /**
     * Extract information about the generated functions from the contract module.
     */
    private extractFunctions(
        mainContract: FuncAstModule,
    ): FuncAstFunctionDefinition[] {
        const contractFunctions = mainContract.entries.reduce((acc, e) => {
            if (
                e.kind ===
                "function_definition" /* TODO: || e.kind === "function_declaration" */
            ) {
                acc.push(e);
            }
            return acc;
        }, [] as FuncAstFunctionDefinition[]);
        const generatedFunctions = this.funcCtx.getFunctions();
        return [...contractFunctions, ...generatedFunctions];

        // // Check dependencies
        // const missing: Map<string, string[]> = new Map();
        // for (const f of contract.entries.values()) {
        //     for (const d of f.depends) {
        //         if (!this.#functions.has(d)) {
        //             if (!missing.has(d)) {
        //                 missing.set(d, [f.name]);
        //             } else {
        //                 missing.set(d, [...missing.get(d)!, f.name]);
        //             }
        //         }
        //     }
        // }
        // if (missing.size > 0) {
        //     throw new Error(
        //         `Functions ${Array.from(missing.keys())
        //             .map((v) => `"${v}"`)
        //             .join(", ")} wasn't rendered`,
        //     );
        // }

        // // All functions
        // let all = Array.from(this.#functions.values());

        // // Remove unused
        // if (!debug) {
        //     const used: Set<string> = new Set();
        //     const visit = (name: string) => {
        //         used.add(name);
        //         const f = this.#functions.get(name)!;
        //         for (const d of f.depends) {
        //             visit(d);
        //         }
        //     };
        //     visit("$main");
        //     all = all.filter((v) => used.has(v.name));
        // }

        // Sort functions
        // const sorted = topologicalSort(all, (f) =>
        //     Array.from(f.depends).map((v) => this.#functions.get(v)!),
        // );
        // return sorted;
    }

    /**
     * Generates a file that contains declarations of all the generated Func functions.
     */
    private generateHeaders(
        generated: GeneratedFilesInfo,
        functions: FuncAstFunctionDefinition[],
    ): void {
        const m = makeModule();
        m.entries.push(
            makeComment(
                "",
                `Header files for ${this.abiSrc.name}`,
                "NOTE: declarations are sorted for optimal order",
                "",
            ),
        );
        functions.forEach((f) => {
            // if (f.code.kind === "generic") {
            m.entries.push(makeComment(f.name));
            if (
                f.attrs.find((attr) => attr !== "impure" && attr !== "inline")
            ) {
                f.attrs.push("inline_ref");
            }
            m.entries.push(declarationFromDefinition(f));
            // }
        });
        generated.files.push({
            name: `${this.basename}.headers.fc`,
            code: new FuncFormatter().dump(m),
        });
    }

    private generateStdlib(
        generated: GeneratedFilesInfo,
        functions: FuncAstFunctionDefinition[],
    ): void {
        //     const stdlibHeader = trimIndent(`
        //     global (int, slice, int, slice) __tact_context;
        //     global slice __tact_context_sender;
        //     global cell __tact_context_sys;
        //     global int __tact_randomized;
        // `);
        //
        //     const stdlibFunctions = tryExtractModule(functions, "stdlib", []);
        //     if (stdlibFunctions) {
        //         generated.imported.push("stdlib");
        //     }
        //
        //     const stdlib = emit({
        //         header: stdlibHeader,
        //         functions: stdlibFunctions,
        //     });
        //
        //     generated.files.push({
        //         name: this.basename + ".stdlib.fc",
        //         code: stdlib,
        //     });
    }

    private generateNative(generated: GeneratedFilesInfo): void {
        // const nativeSources = getRawAST(ctx).funcSources;
        // if (nativeSources.length > 0) {
        //     generated.imported.push("native");
        //     generated.files.push({
        //         name: this.basename + ".native.fc",
        //         code: emit({
        //             header: [...nativeSources.map((v) => v.code)].join("\n\n"),
        //         }),
        //     });
        // }
    }

    private generateConstants(
        generated: GeneratedFilesInfo,
        functions: FuncAstFunctionDefinition[],
    ): void {
        // const constantsFunctions = tryExtractModule(
        //     functions,
        //     "constants",
        //     imported,
        // );
        // if (constantsFunctions) {
        //     generated.imported.push("constants");
        //     generated.files.push({
        //         name: this.basename + ".constants.fc",
        //         code: emit({ functions: constantsFunctions }),
        //     });
        // }
    }

    private generateStorage(
        generated: GeneratedFilesInfo,
        functions: FuncAstFunctionDefinition[],
    ): void {
        // const emittedTypes: string[] = [];
        // const types = getSortedTypes(ctx);
        // for (const t of types) {
        //     const ffs: WrittenFunction[] = [];
        //     if (
        //         t.kind === "struct" ||
        //         t.kind === "contract" ||
        //         t.kind == "trait"
        //     ) {
        //         const typeFunctions = tryExtractModule(
        //             functions,
        //             "type:" + t.name,
        //             generated.imported,
        //         );
        //         if (typeFunctions) {
        //             generated.imported.push("type:" + t.name);
        //             ffs.push(...typeFunctions);
        //         }
        //     }
        //     if (t.kind === "contract") {
        //         const typeFunctions = tryExtractModule(
        //             functions,
        //             "type:" + t.name + "$init",
        //             generated.imported,
        //         );
        //         if (typeFunctions) {
        //             generated.imported.push("type:" + t.name + "$init");
        //             ffs.push(...typeFunctions);
        //         }
        //     }
        //     if (ffs.length > 0) {
        //         const header: string[] = [];
        //         header.push(";;");
        //         header.push(`;; Type: ${t.name}`);
        //         if (t.header !== null) {
        //             header.push(`;; Header: 0x${idToHex(t.header)}`);
        //         }
        //         if (t.tlb) {
        //             header.push(`;; TLB: ${t.tlb}`);
        //         }
        //         header.push(";;");
        //
        //         emittedTypes.push(
        //             emit({
        //                 functions: ffs,
        //                 header: header.join("\n"),
        //             }),
        //         );
        //     }
        // }
        // if (emittedTypes.length > 0) {
        //     generated.files.push({
        //         name: this.basename + ".storage.fc",
        //         code: [...emittedTypes].join("\n\n"),
        //     });
        // }
    }
}
